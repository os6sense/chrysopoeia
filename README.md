Chrysopoeia
===========
An experimental parrallel transformative selector-based templating system for
Elixir.

Goals
===========
- Significantly increase rendering speed of HTML templates.
- Provide a means for writing templates in a functional style.
- Seperation of presentation/logic 
- Provide cache mechanisms to re-output content that has already been created.
- compiled
- Easy to use.
- Well documented.
- Well Tested.

Preamble
==========
I recently decided to learn Elixir and Phoenix and have been ... impressed in
general by them but I was somewhat agahst of the PHP style ".ex" templates 
I was seeing.

and my mind turned back to XSLT.  Of course, XSL never really gained the
traction that (I think) it deserved because it was so damn complicatied but it
was good to see that some of the basic ideas are alive and well in projects
such as Enlive, Tritium, Moulder et al.

Hence Chrysopoeia is a 

Selector Syntax:

I was VERY tempted to use an XPATH syntax and may well add one as an alternative
at a later date but for now the syntax is based on CSS 3.0.

Actions
=======
# Action 0 - TESTS. No feature shall be added without an accompaning test. 
             

# Action 0 - Benchmark. At this point can compare to eex but also
#            compare to erlang ones at a later date.

Libraries that may be useful 
============================
okeuday/trie

floki - sort of does what I want but dependent on mochiweb for tokenization,
parsing and generating the parse tree.

Structure
=========

urlreader
filereader
reader - get the document from a file or a url


tokenizer - tokenize a html document 
parser

Tree - A structure for the parse tree. Zipper tree? Longer term the parser
       should generate this directly but in the short term a converstion 
       nethod will suffice.

Selector - CSS syntax based selectors acting on the tree

Transforms - macros and functions to apply the transforms to the tree


# Mockup
========
# Note it should be possible to require the defhtmls from another file.


- support:
- Insert a snippet of html generated by a different transform
- node deletion
- argument transformation
- text transformation
- repeating node replacement


- Transforms are performed in the following order

1) Deletes - note, can be done during the initial copy operation
2) Text | Arguments
3) Nodes
4) Inserts


Important operators
- select value of current node (e.g. .)
- concatination on current value

For an api it seems that I want to use the tuple notation. e.g. 

{:value, "new_value" } - would transform the value attribute of the selected 
                         element to "new_value"

{1, 2, 3, 4} - would transform the values of whatever tags matched the selector
               to 1, 2, 3, and 4; ASSUMING that 4 values were matched by the
               selector


transforms = MyTranformations.init("local.html")
transformed = Transforms.apply(conn, transforms)

deftransforms MyTranformations do
  @source "local.html"

  // deftransforms - adds an init method
  def init(source_file \\ @source) do
    Chrysopoeia.Reader.read(source_file) 
      |> Chrysopoeia.Template.store
  end

  // another useful macro might be the transform order allowing it to be
  // overridden/changed.
  def transform_order do
    [:deletes, :text_and_arguments, :nodes, :inserts]
  end

  // conn?
  // what about TRs?
  // repeating
  // e.g. <tr></td></td></td></td></td></td></td></td></tr>
  // would get filed with {name, date, qty, price}
  transform_nodes stock_table("table[id=table_1]/tr/td") do
      {name, date, qty, price} = Model.get(model, :price_data)
  end

  # e.g. <div id="hl"><span></span><span></span></div>
  # The spans would be replaced with the values from the tupple
  transform_node headline("div[id=hl]/span") do
      { Model.get(model, :main_heading), Model.get(model, :subtitle) } 
  end


  transform_argument p_args("input[name=_csrf_token]") do
    {:value, Model.get(model, :csrf_token}
    if assigns[:somevalue] do
      set_arg("value", Model.get(model, :something)
    end
  end
  
  transform_argument form_action("form[id=main]") do
   if Model.get(model, :action) == :create
     {:action, "/#{Model.get(model, :resource_name)}"}
   else
     {:action, "/#{Model.get(model, :resource_name)}/#{Model.get(model, :resource_id)}"}
   end
  end

  transform_text time("[id=time]") do
    // check if the field is a text field if so:
    { . <> :erlang.now() }
  end

  # Variants for insert may be needed.
    insert_text | insert_html
    insert_IO(file | url)
    insert_cached(:cache_id)
    insert_transformed(file | url, Transforms)

  insert add_form_patch("form[id=main]") do
    if Model.get(model, :action) != :create
      "<input name="_method" type="hidden" value="patch" />"
    end
  end
    
  insert recently_browsed("id=recently_browsed") do
    "Hello World"
    
    insert text from file OR cache OR another transformation
  end

  # Similarly to insert, delete may need variants 
  # delete_argument
  # delete_node
  # delete_nodes
  # delete_text
  # HOWEVER, it may be preserable to have these operate as part of the
  # transform

  delete hidden_field("id=hidden_field" do 
    if Model.get(model, :action) != :create

    end
  end

end


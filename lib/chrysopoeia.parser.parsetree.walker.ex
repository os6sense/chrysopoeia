defmodule Chrysopoeia.Parser.ParseTree.Walker do
  # TODO : NEXT, pass in parent path
  @moduledoc
  """
    Methods for walking the parsetree as generated by Floki/Mochiweb.

    The parsetree is of the syntax:
    
        pt = {element, [arguments], [<{pt}>...]]} 

    where pt can be a recuring child element or re-occur multiple times.

  """
  require Logger

  defmacro function(:copy) do
    quote do
      fn(t, a) -> 
        Logger.debug "copy: #{inspect t} -- #{inspect a}"
        {t, a}
      end
    end
  end


  @doc ~S"""
    t: pt, as described above.
    fns: A list of selector/transform functions to be applied during the
         walk. See Transform.transform/2 
         a single function in the function list is of the form:

            fn(tuple, accumulator)

          e.g. the default copy function is:
            fn(t = {e, a, c}, acc) -> t end]
  """
  @spec walk(Tuple, List) :: Tuple
  def walk(t, fns \\ [function(:copy)]) when is_tuple(t) do
    Logger.debug "Walk"
    _walk(t, fns, nil)
  end

  @doc ~S""" 
    matches a text node. 
  """
  def _walk(text , _fns, acc) when is_binary(text) do
    Logger.debug "Text Node 2 - #{inspect text} || #{String.strip(text)}"
    {String.strip(text), acc}
  end
    
  # matches a text node with children
  def _walk(t = { _, _, [c]}, fns, acc) when is_binary(c) do
    Logger.debug "Text Node 3 - #{inspect t} -- #{inspect acc}"
    reduce_node(fns, t)
  end

  @doc ~S"""
    Add the (e)lement and (a)rguments to the accumulator, apply the walk
    function to the tuple elements within the list c
  """
  def _walk(t = {e, _a, c}, fns, acc) when is_list(c) do
    Logger.debug "List Walk A - #{inspect e} -- #{inspect acc}"

    {{e, a, c}, acc} = reduce_node(fns, t)

    Logger.debug "List Walk B - #{inspect e} -- #{inspect acc}"

    unless e == :delete do
      Logger.debug "List Walk C - #{inspect e} -- #{inspect acc}"

      {children, acc} = Enum.map_reduce(c, [], fn
        (child, r_acc) -> 
          Logger.debug "List Walk Map Reduce - #{inspect child} -- #{inspect r_acc}"

          {t, a} = _walk(child, fns, r_acc)
          {t, r_acc ++ a} 
      end)

      {{e, a, Enum.filter(children, &fn_filter_child/1)}, acc}
    else
      # :delete, unless its the top html tag, will get parsed by the calling
      # filter
      {{e, a, c}, acc}
    end
  end


  @doc ~S"""
    Matches the tuple with no children (i.e an empty list) as the last element.
  """
  def _walk(t = {_, _, []}, fns, acc) do
    Logger.debug "Empty Last Element (fns) #{inspect t}"
    reduce_node(fns, t)
  end

  @doc ~S"""
    Matches a totally empty element.
  """
  def _walk({}, _fns, _acc) do
    Logger.debug "Empty Element (fns)"
    {{}, []}
  end

  # ========================= 
  # -------- Helpers --------
  # ========================= 
  # Used by Enum.filter to remove tupple with :delete as the first value
  defp fn_filter_child({e, _a, _c}), do: e != :delete
  defp fn_filter_child({{e, _a, _c}, acc}), do: e != :delete
  defp fn_filter_child(text) when is_binary(text), do: true
  defp fn_filter_child(nil), do: false

  # Apply the fncs to the node - really only useful for text nodes or those
  # without children
  defp reduce_node(fns, t), 
    do: Enum.reduce([[]] ++ fns, fn(fun, r_acc) -> fun.(t, r_acc) end)
end

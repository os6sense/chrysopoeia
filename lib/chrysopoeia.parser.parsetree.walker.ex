defmodule Chrysopoeia.Parser.ParseTree.Walker do
  # TODO : NEXT, pass in parent path as [{tag, attr}, {tag, attr}]
  # DONE

  # TODO NEXT: do I need to include sibling tags?

  # TODO: Function application: In order to apply functions in a single pass
  #       these need to be tagged and ordered, hence I should probably be 
  #       defining the function as a tuple e.g. {:delete, fn ..body..}

  #TODO:  path in walk needs more info for css matches. The question is what
  #       and how much. To support:
  #         nth-child, nth-last-child, first-child and last-child
  #
  #         :we need to know 
  #
  #           {elements position, how many children}
  #
  #         same for nth-of-type, first-of-type etc.
  # 
  #       HOWEVER!!!: we also want to support:

  #         E + F   - Adjacent sibling combinator
  #         an F element immediately preceded by an E element   
  #
  #         E ~ F   - General sibling combinator
  #         an F element preceded by an E element
  #
  #         if we consider passing in the following with the * marking
  #         the current elment
  #         
  #         {["E", "P", "P", "P", "E", "F" *, "E", "F", "P"], {6, 9}, {1, 2}} 
  #          
  #         This allows us to match on everything *except* where the args
  #         are also used. e.g. E[id=id_1] + F

  @moduledoc
  """
    Methods for walking the parsetree as generated by Floki/Mochiweb.

    The parsetree is of the syntax:
    
        pt = {"element", [{"arg_name", "arg_value"}, ...], [<{pt}>...]]} 

    where pt can be a recuring child element or re-occur multiple times.

  """
  require Logger
  require Chrysopoeia.Parser.ParseTree.Walker.Functions, as: Functions
  require Chrysopoeia.Accumulator, as: Accumulator

  @doc ~S"""
    pt:  As described above.
    fns: A list of selector/transform functions to be applied during the
         walk. See Transform.transform/2 
         
         A single function in the function list is of the form:

         {:id, fn(tuple, accumulator)}

          e.g. the default copy function is:
          {:transform, fn(t = {e, a, c}, acc) -> t end]}
  """
  @spec walk(Tuple, List) :: Tuple
  def walk(pt, fns \\ [Functions.function(:copy)]) when is_tuple(pt) do
    Logger.debug "---------------- NEW WALK ------------------"
    _walk(pt, Functions.order(fns), Accumulator.create , [])
  end

  @doc ~S""" 
    matches a text node. 
  """
  def _walk(text , _fns, acc, meta) when is_binary(text) do
    #Logger.debug "TEXT NODE 2 - #{inspect text} || #{String.strip(text)}"
    #Logger.debug "TEXT NODE 2 META: #{inspect meta}"
    {String.strip(text), acc}
  end
    
  # matches a text node with children
  def _walk(t = { _, _, [c]}, fns, acc, meta) when is_binary(c) do
    #Logger.debug "TEXT NODE 3 - #{inspect t} -- META: #{inspect meta}"
    apply_functions(fns, t, update_meta(meta, t, 0), acc)
  end

  @doc ~S"""
    Add the (e)lement [and (a)rguments to the accumulator?], apply the walk
    function to the tuple elements within the list c
  """
  def _walk(t = {e, _a, c}, fns, acc, meta) when is_list(c) do
    #Logger.debug "LW A - #{inspect e} -- #{inspect acc}"
    #Logger.debug "LW META: #{inspect meta}" 
   
    {{e, a, c}, acc} = apply_functions(fns, t, meta, acc)

    #Logger.debug "LW B - #{inspect e} -- acc: #{inspect acc}"
    #Logger.debug "LW META: #{inspect meta}" 

    unless e == :delete do
      {children, {acc, idx}} = Enum.map_reduce(c, {acc, 1}, fn
        (child, {lacc, idx}) -> 
          meta = update_meta(meta, {e, a, c}, idx)
          {r_tree, r_acc} = _walk(child, fns, lacc, meta)
          {r_tree, {r_acc, idx + 1}}
      end)
      #Logger.debug "LW -- LEAVING #{e} #{inspect acc}\n"
      {{e, a, Enum.filter(children, &fn_filter_child/1)}, acc}
    else
      #Logger.debug "LW -- LEAVING #{e}\n"
      {{e, a, c}, acc} # :delete, unless its the html tag, will get parsed 
                       # by the calling _walk
    end
  end

  @doc ~S"""
    Matches the tuple with no children (i.e an empty list) as the last element.
  """
  def _walk(t = {_, _, []}, fns, acc, meta) do
    #Logger.debug "LAST ELEMENT (empty) #{inspect t}"
    apply_functions(fns, t, update_meta(meta, t, 0), acc)
  end

  @doc ~S"""
    Matches a totally empty element.
  """
  def _walk({}, _fns, _acc, _meta) do
    #Logger.debug "EMPTY ELEMENT"
    {{}, []}
  end

  # On decent the children become the siblings and the children are replaced.
  # NB : Possible bug - is it being applied to immediate descendents e.g. head, body?
  defp update_meta(meta, {e, a, c}, idx \\ 0) do
    c_len = length(c)
    #[ {:path, (meta[:path] || []) ++ [{e, a}] },
    [ {:path, [{e, a}] ++ (meta[:path] || []) }, # reverse path for descendant/child search
      {:children, {Enum.map(c, fn({e, _a, _}) -> e; (_) -> "TEXT" end), idx, c_len} },
      {:siblings, meta[:children] || {[], 0, 0} } ]
  end

  # Apply the fncs to the node 
  defp apply_functions(fns, t = {e, a, c}, meta, acc) do
    Enum.reduce([acc] ++ fns, fn({_tag, fun}, lacc) -> fun.({e, a, c}, meta, lacc) end)
  end

  # ========================= 
  # -------- Helpers --------
  # ========================= 
  # NB: I may need meta/path here
  # Used by Enum.filter to remove tupple with :delete as the first value
  defp fn_filter_child({e, _a, _c}), do: e != :delete
  defp fn_filter_child({{e, _a, _c}, _acc}), do: e != :delete
  defp fn_filter_child(text) when is_binary(text), do: true
  defp fn_filter_child(nil), do: false
end

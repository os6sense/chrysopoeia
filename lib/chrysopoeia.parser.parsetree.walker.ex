defmodule Chrysopoeia.Parser.ParseTree.Walker do
  # TODO : NEXT, pass in parent path as [{tag, attr}, {tag, attr}]
  # DONE

  # TODO NEXT: do I need to include sibling tags?

  # TODO: Function application: In order to apply functions in a single pass
  #       these need to be tagged and ordered, hence I should probably be 
  #       defining the function as a tuple e.g. {:delete, fn ..body..}

  #TODO:  path in walk needs more info for css matches. The question is what
  #       and how much. To support:
  #         nth-child, nth-last-child, first-child and last-child
  #
  #         :we need to know 
  #
  #           {elements position, how many children}
  #
  #         same for nth-of-type, first-of-type etc.
  # 
  #       HOWEVER!!!: we also want to support:

  #         E + F   - Adjacent sibling combinator
  #         an F element immediately preceded by an E element   
  #
  #         E ~ F   - General sibling combinator
  #         an F element preceded by an E element
  #
  #         if we consider passing in the following with the * marking
  #         the current elment
  #         
  #         {["E", "P", "P", "P", "E", "F" *, "E", "F", "P"], {6, 9}, {1, 2}} 
  #          
  #         This allows us to match on everything *except* where the args
  #         are also used. e.g. E[id=id_1] + F

  @moduledoc
  """
    Methods for walking the parsetree as generated by Floki/Mochiweb.

    The parsetree is of the syntax:
    
        pt = {"element", [{"arg_name", "arg_value"}, ...], [<{pt}>...]]} 

    where pt can be a recuring child element or re-occur multiple times.

  """
  require Logger
  require Chrysopoeia.Parser.ParseTree.Walker.Functions, as: Functions

  @doc ~S"""
    pt:  As described above.
    fns: A list of selector/transform functions to be applied during the
         walk. See Transform.transform/2 
         
         A single function in the function list is of the form:

         {:id, fn(tuple, accumulator)}

          e.g. the default copy function is:
          {:transform, fn(t = {e, a, c}, acc) -> t end]}
  """
  @spec walk(Tuple, List) :: Tuple
  def walk(pt, fns \\ [Functions.function(:copy)]) when is_tuple(pt) do
    Logger.debug "Walk"
    # BUG: at some point we are initialising the accumulator
    _walk(pt, Functions.order(fns), nil, [])
  end

  @doc ~S""" 
    matches a text node. 
  """
  def _walk(text , _fns, acc, meta) when is_binary(text) do
    Logger.debug "TEXT NODE 2 - #{inspect text} || #{String.strip(text)}"
    Logger.debug "TEXT NODE 2 META: #{inspect meta}"
    {String.strip(text), acc}
  end
    
  # matches a text node with children
  def _walk(t = { _, _, [c]}, fns, acc, meta) when is_binary(c) do
    Logger.debug "TEXT NODE 3 - #{inspect t} -- #{inspect acc}"
    meta = update_meta(meta, t)
    Logger.debug "TEXT NODE 3 META: #{inspect meta }"
    reduce_node(fns, t)
  end

  @doc ~S"""
    Add the (e)lement and (a)rguments to the accumulator, apply the walk
    function to the tuple elements within the list c
  """
  def _walk(t = {e, _a, c}, fns, acc, meta) when is_list(c) do
    Logger.debug "List Walk A - #{inspect e} -- #{inspect acc}"
    Logger.debug "META: #{inspect meta}"

    {{e, a, c}, acc} = reduce_node(fns, t)

    Logger.debug "List Walk B - #{inspect e} -- acc: #{inspect acc}"

    unless e == :delete do
      #{children, acc} = Enum.map_reduce(c, [], fn
      {children, acc} = Enum.map_reduce(c, acc, fn
        (child, mr_acc) -> 
          Logger.debug "List Walk Map Reduce - C:#{inspect child} -- r_acc:#{inspect mr_acc}."

          {t, a1} = _walk(child, fns, mr_acc, update_meta(meta, {e, a, c}) )
          {t, Functions.update_accumulator(mr_acc, a1)} 
      end)

      { {e, a, Enum.filter(children, &fn_filter_child/1)}, acc}
    else
      # :delete, unless its the html tag, will get parsed by the calling _walk
      {{e, a, c}, acc}
    end
  end

  @doc ~S"""
    Matches the tuple with no children (i.e an empty list) as the last element.
  """
  def _walk(t = {_, _, []}, fns, acc, meta) do
    Logger.debug "Empty Last Element (fns) #{inspect t}"
    meta = update_meta(meta, t)
    Logger.debug "EMPTY LAST ELEMENT META: #{inspect meta }"
    reduce_node(fns, t)
  end

  @doc ~S"""
    Matches a totally empty element.
  """
  def _walk({}, _fns, _acc, meta) do
    Logger.debug "EMPTY ELEMENT"
    {{}, []}
  end

  # {[path], ["E", "P", "P", "P", "E", "F" *, "E", "F", "P"], {6, 9}, {1, 2}} 
  # on decent the children become the siblings and the children are replaced.
  defp update_meta(meta, t = {e, a, c}) do
    [ {:path, (meta[:path] || []) ++ [{e}] },
      {:children, {Enum.map(c, fn({e, a, _}) -> e; (t) -> "TEXT" end), 0, length(c)} },
      {:siblings, meta[:children] || {[], 0, 0} } ]
  end

  # Apply the fncs to the node - really only useful for text nodes or those
  # without children
  defp reduce_node(fns, t) do
    Enum.reduce([[]] ++ fns, fn
      ({tag, fun}, r_acc) -> fun.(t, r_acc) 
    end)
  end

  # ========================= 
  # -------- Helpers --------
  # ========================= 
  # NB: I may need meta/path here
  # Used by Enum.filter to remove tupple with :delete as the first value
  defp fn_filter_child({e, _a, _c}), do: e != :delete
  defp fn_filter_child({{e, _a, _c}, acc}), do: e != :delete
  defp fn_filter_child(text) when is_binary(text), do: true
  defp fn_filter_child(nil), do: false

end

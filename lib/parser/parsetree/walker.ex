defmodule Chrysopoeia.Parser.ParseTree.Walker do


  #TODO:  path in walk needs more info for css matches. The question is what
  #       and how much. To support:
  #         nth-child, nth-last-child, first-child and last-child
  #
  #         :we need to know 
  #
  #           {elements position, how many children}
  #
  #         same for nth-of-type, first-of-type etc.
  # 
  #       HOWEVER!!!: we also want to support:

  #         E + F   - Adjacent sibling combinator
  #         an F element immediately preceded by an E element   
  #
  #         E ~ F   - General sibling combinator
  #         an F element preceded by an E element
  #
  #         if we consider passing in the following with the * marking
  #         the current elment
  #         
  #         {["E", "P", "P", "P", "E", "F" *, "E", "F", "P"], {6, 9}, {1, 2}} 
  #          
  #         This allows us to match on everything *except* where the args
  #         are also used. e.g. E[id=id_1] + F

  @moduledoc
  """
    Methods for walking the parsetree as generated by Floki/Mochiweb.

    The parsetree is of the syntax:
    
        pt = {"element", [{"arg_name", "arg_value"}, ...], [<{pt}>...]]} 

    where pt can be a recuring child element or re-occur multiple times.

  """
  require Logger
  require Chrysopoeia.Parser.ParseTree.Walker.Functions, as: Functions
  require Chrysopoeia.Accumulator, as: Accumulator

  @doc ~S"""
    pt:  As described above.
    fns: A list of selector/transform functions to be applied during the
         walk. See Transform.transform/2 
         
         A single function in the function list is of the form:

         {:id, fn(tuple, accumulator)}

          e.g. the default copy function is:
          {:transform, fn(t = {e, a, c}, acc) -> t end]}
  """
  @spec walk(Tuple, List) :: Tuple
  def walk(pt, fns \\ [Functions.function(:copy)]) when is_tuple(pt) do
    #Logger.debug "------------------------------------------------------------"
    #Logger.debug "------------------------ NEW WALK --------------------------"
    #Logger.debug "------------------------------------------------------------"
    _walk(pt, Functions.order(fns), Accumulator.create , [])
  end

  # On decent the children become the siblings and the children are replaced.
  # TODO: This is by far the most expensive function - look at optimisation
  def update_meta(meta, {e, a, c}, idx \\ 0) do
    c_len = length(c)
    #Logger.debug "UPDATE META PRE: #{inspect meta}"
    [ {:path, [{e, a}] ++ (meta[:path] || []) }, # reverse path for descendant/child search
      {:children, {Enum.map(c, fn({e, a, _}) -> {e, a}; (_) -> "TEXT" end), idx, c_len} },
      {:siblings, meta[:children] || {[], 0, 0} } ]
    #Logger.debug "UPDATE META POST: #{inspect meta}"
  end

  @doc ~S""" 
    matches a text node. 
  """
  def _walk(text , fns, acc, meta) when is_binary(text) do
    #Logger.debug "TEXT NODE 2 - #{inspect text} || #{String.strip(text)}"
    #Logger.debug "TEXT NODE 2 META: #{inspect meta}"

    # The mochiweb parser leaves whitespacing in, possibly only as an artifact
    # of testing, hence we clean the text here. 
    
    # I get the feeling that the fact this isn't a function applied to the
    # tree is indicative that something is wrong in the design.

    #IO.puts "TEXT WALK #{text}"
    #apply_functions(fns, text, meta, acc)
    {String.strip(text), acc}
  end

  # matches a comment
  def _walk(t = { :comment, text}, fns, acc, meta) when is_binary(text) do
    # Logger.debug "COMMENT"
    {text, acc}
  end

  # matches a text node with children
  def _walk(t = { _, _, [c]}, fns, acc, meta) when is_binary(c) do
    #Logger.debug "TEXT NODE 3 - #{inspect t} -- META: #{inspect meta}"
    #IO.puts "TEXT WITH CHILDREN #{c}"
    apply_functions(fns, t, update_meta(meta, t, 0), acc)
  end

  @doc ~S"""
    Add the (e)lement [and (a)rguments to the accumulator?], apply the walk
    function to the tuple elements within the list c
  """
  def _walk(t = {e, _a, c}, fns, acc, meta) when is_list(c) do
    #Logger.debug "LW A - #{inspect e} -- #{inspect acc}"
    #Logger.debug "LW META: #{inspect meta}" 
   
    meta = update_meta(meta, t)

    {{e, a, c}, acc} = apply_functions(fns, t, meta, acc)

    #Logger.debug "LW B - #{inspect e} -- acc: #{inspect acc}"
    #Logger.debug "LW META: #{inspect meta}" 

    unless e == :delete do
      {children, {acc, idx}} = Enum.map_reduce(c, {acc, 1}, fn
        (child, {lacc, idx}) -> 
          
          #Logger.debug "LW C - #{inspect e} -- acc: #{inspect acc}"
          #Logger.debug "LW META: #{inspect meta}" 
          meta = update_meta(meta, {e, a, c}, idx)

          {r_tree, r_acc} = _walk(child, fns, lacc, meta)
          {r_tree, {r_acc, idx + 1}}
      end)
      #Logger.debug "LW -- LEAVING #{e} #{inspect acc}\n"
      {{e, a, Enum.filter(children, &fn_filter_child/1)}, acc}
    else
      #Logger.debug "LW -- LEAVING #{e}\n"
      {{e, a, c}, acc} # :delete, unless its the html tag, will get parsed 
                       # by the calling _walk
    end
  end

  @doc ~S"""
    Matches the tuple with no children (i.e an empty list) as the last element.
  """
  def _walk(t = {_, _, []}, fns, acc, meta) do
    #Logger.debug "LAST ELEMENT (empty) #{inspect t}"
    apply_functions(fns, t, update_meta(meta, t, 0), acc)
  end

  @doc """
    Matches a totally empty element.
  """
  def _walk({}, _fns, _acc, _meta) do
    #Logger.debug "EMPTY ELEMENT"
    {{}, []}
  end

  # Apply the fncs to the node 
  defp apply_functions(fns, t = {e, a, c}, meta, acc) do
    Enum.reduce(fns, acc, fn
      ({_, fun}, lacc) -> 
        # Do I still need to fix the accumulator in the transforms?
        # seems I do but look into that, I may be repeating work.
        if is_tuple(lacc) do
          tree = lacc |> elem(0)
        else
          tree = t
        end
          
        fun.(tree, meta, lacc) 
    end)
  end

  # ========================= 
  # -------- Helpers --------
  # ========================= 
  # NB: I may need meta/path here
  # Used by Enum.filter to remove tupple with :delete as the first value
  defp fn_filter_child({e, _a, _c}), do: e != :delete
  defp fn_filter_child({{e, _a, _c}, _acc}), do: e != :delete
  defp fn_filter_child(text) when is_binary(text), do: true
  defp fn_filter_child(nil), do: false
end
